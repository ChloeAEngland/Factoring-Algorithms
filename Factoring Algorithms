from math import log
from random import randint
from matplotlib import pyplot as plt
from time import time

def gcd(a,b):#implements the euclidean algorithm for computing gcd over ZZ
    while b > 0:
        a,b = b,a%b
    return a

def modinv(a,n):#computes a^-1 mod n using extended euclidean algorithm
    a%=n
    r=(0,1)
    #s=(1,0)
    N=(n,a)
    #at all times, we should have N[0]=r[0]*a+s[0]*n
    while N[1]!=0:
        d=N[0]//N[1] #
        r=(r[1],r[0]-d*r[1])
        #s=(s[1],s[0]-d*s[1])
        N=(N[1],N[0]%N[1])
    assert N[0]==1# gcd(a,n)!=1
    return r[0]%n

def modexp(a,m,n):#computes a**m%n by repeated squaring
    if m==1:
        return a%n
    elif m%2 == 0:
        return modexp((a*a)%n,m//2,n)
    else:
        return (a*modexp((a*a)%n,(m-1)//2,n))%n
   
def primesieve(B):#implements sieve of Eratosthenes
    A=list(range(2,B+1))
    primes = list()
    while A != []:
        p = A[0]
        for i in A:
            if i%p == 0:
                A.remove(i)
        primes.append(p)
    return primes

def lcm(B):#computes lcm of 1,2,3,...,B
    primes = primesieve(B)
    product = 1
    for p in primes:
        product *= p**(int(log(B ,p))) 
    return product

def pollard(N,B=15,m=0):#implements pollards p-1 algorithm
    a = 2
    if not m:
        m = lcm(B)
    while a < 11:    
        am_1 = modexp(a,m,N) - 1
        factor = gcd(am_1,N)
        if 1 < factor < N:
            return factor,N//factor
        else:
            a +=1
    return -1

def strongTrial(n,a):#use strong test
    #n-1=2^st
    t=n-1
    s=0
    while t%2==0:
        t//=2
        s+=1
    a=modexp(a,t,n)
    if a==1:
        return True
    for i in range(s):
        if a==n-1:
            return True
        a=(a*a)%n
    return False

def isPrime(n):#use strong test 10 times
    for i in range(10):
        a=randint(1,n-1)
        if gcd(a,n)>1:
            return False
        if not strongTrial(n,a):
            return False
    return True

def NvBpollard(maxB=21):#plots the minimum B needed for various odd values of N
    m=[1]
    for b in range(1,maxB):
        m.append(lcm(b))#precompute all the lcms!
    N = list()
    B = list()
    numOfFails=0#we want to count num of fails
    for i in range (1,10000):
        n=2
        while isPrime(n):
            n = 2*randint(2,10000000)+1
        N.append(n)
        b = 1
        while b<maxB:
            if pollard(n,m=m[b]) == -1:
                b += 1
            else:
                B.append(b)
                break
        if b==maxB: #sends a fail to -1
            B.append(-10)#to make it obvious it which don't work
            numOfFails+=1
    plt.scatter(N,B,s=0.1)
    plt.xlabel('N to be factorised')
    plt.ylabel('smallest B to factorise N')
    plt.show()
    return numOfFails
  
#############################################################################################             
               
def ECadd(a,N,P,Q): # add points P & Q over the elliptic curve y^2 = x^3 + ax + 1
    if P == "inf": #case 1: P is infinity
        return Q
    if Q == "inf": #case 2: Q is infinity
        return P
    if P[0] == Q[0] and (P[1] + Q[1])%N==0: #case 3: points on same x line
        return "inf"
    else: #compute gradient, use this to find new (x,y)
        if P==Q:
            grad = ((3*P[0]**2 + a)*(modinv(2*P[1],N)))%N
        else:
            grad = ((P[1]-Q[1])*(modinv(P[0]-Q[0],N)))%N
        x = (grad**2 - P[0]- Q[0])%N #x co-ord of output (R in wstein ENT alg 6.2.1)
        y = (-grad*x-P[1]+grad*P[0])%N
        return (x,y)
           
def lenstraTrial(a,N,m):#does lenstras algorithm on the EC y^2=x^3+ax+1
    P=(0,1)
    mP=(0,1)# use this to compute mP
    m=bin(m)[2:]#this is m in binary as a string of 0s and 1s
    #now calculate m*P
    for bit in m[1:]:#looks at bits but ignores the first to do repeated doubling
        try:
            mP=ECadd(a,N,mP,mP)
        except:#then we have found a nonzero gcd in denom, which is 2P[1] in ECadd
            return gcd(N,mP[1])#y1 is a non-unit in Z/NZ so this is a non-trivial factor
        if bit=='1':
            try:
                mP=ECadd(a,N,mP,P)
            except: #we found a non 0 gcd in denom, which is P[0]-Q[0]=mP[0]
                return gcd(N,mP[0])
    return N#failed to find a non-trivial factor

def lenstra(N,B=15,numTrials=10,m=0):#trying different elliptic curves until one works
    if N%2==0:
        return 2,N//2
    if not m:#if we have pre-computed an m, don't compute it again!
        m=lcm(B)
    for i in range(numTrials):
        a=randint(1,N-1)
        g=lenstraTrial(a,N,m)
        if 1<g<N:
            return g,N//g
    return -1#failed to find a factor

def NvBlenstra(maxB=21):#plots the minimum B needed for various odd values of N
    m=[1]
    for b in range(1,maxB):
        m.append(lcm(b))#precompute all the lcms!
    N = list()
    B = list()
    numOfFails=0#we want to count num of fails
    for i in range (1,10000):
        n=2
        while isPrime(n):
            n = 2*randint(2,10**10)+1
        N.append(n)
        b = 1
        while b<maxB:
            if lenstra(n,m[b]) == -1:
                b += 1
            else:
                B.append(b)
                break
        if b==maxB: #sends a fail to -1
            B.append(-10)#to make it obvious it which don't work
            numOfFails+=1
    plt.scatter(N,B,s=0.1)
    plt.xlabel('N to be factorised')
    plt.ylabel('smallest B to factorise N')
    plt.show()
    return numOfFails

def fullFactPollard(N,B=15,m=0): #fully factorises an integer using pollard
    out=[]
    if N==1:
        return out
    if N%2==0:
        while N%2==0:
            out.append(2)
            N//=2
        return out+fullFactPollard(N,B,m)
    if N%3==0:
        while N%3==0:
            out.append(3)
            N//=3
        return out+fullFactPollard(N,B,m)
    if isPrime(N):
        return [N]
    if not m:
        m=lcm(B)
    a,b=pollard(N,B,m)
    fact_a=fullFactPollard(a,B,m)
    fact_b=fullFactPollard(b,B,m)
    out=fact_a+fact_b
    out.sort()
    return out

def fullFactLenstra(N,B=15,m=0): # fully factorises an integer using Lenstra
    out=[]
    if N==1:
        return out
    if N%2==0:
        while N%2==0:
            out.append(2)
            N//=2
        return out+fullFactLenstra(N,B,m)
    if N%3==0:
        while N%3==0:
            out.append(3)
            N//=3
        return out+fullFactLenstra(N,B,m)
    if isPrime(N):
        return [N]
    if not m:
        m=lcm(B)
    a,b=lenstra(N,B,m)
    fact_a=fullFactLenstra(a,B,m)
    fact_b=fullFactLenstra(b,B,m)
    out+=fact_a+fact_b
    out.sort()
    return out

#################################################################################################

def timegraph(reps=10000,B=10,lowerbound=10000,upperbound=100000):
    m=lcm(B)
    tpollard=[]
    tlenstra=[]
    for i in range(reps):
        n=randint(lowerbound,upperbound)*2+1
        start=time()
        for j in range(1):
            f=pollard(n,m=m)
        tpollard.append(log(time()-start))
        start=time()
        for j in range(1):
            f=lenstra(n,m=m)
        tlenstra.append(log(time()-start))
    plt.hist(tpollard,color='r',alpha=0.5,bins=30)
    plt.hist(tlenstra,color='b',alpha=0.5,bins=30)
    plt.legend(['Pollard','Lenstra'])
    plt.xlabel('log of time')
    plt.ylabel('frequency')
    plt.show()

####################################################################################################
#factorising gaussian integers using two methods

class GaussianInteger: #creating a class of gaussian integers
    def __init__(self,real,imag=0): #initialise a gaussian integer 
        self.real=real
        self.imag=imag
    def __repr__(self): # how to represent a gaussian integer
        if self.imag >=0:
            return str(self.real) +"+"+ str(self.imag)+"i"
        else: 
            return str(self.real) + str(self.imag)+"i"
    def __add__(self,other): # defining addition
        return GaussianInteger(self.real+other.real,self.imag+other.imag)
    def __sub__(self,other): #defining subtraction
        return GaussianInteger(self.real-other.real,self.imag-other.imag)
    def __mul__(self,other): #defining multiplication
        return GaussianInteger(self.real*other.real-self.imag*other.imag, self.real*other.imag+self.imag*other.real)
    def conj(self):
        return GaussianInteger(self.real, -self.imag)
    def __floordiv__(self,other): # defining floor division so we can take mods, we dont need truediv
        denom = (other.conj() * other).real
        numer = other.conj() * self
        return GaussianInteger(numer.real//denom,numer.imag//denom)   
    def __mod__(self,other) : #defining mod := the remainder after floor division
        return self-((self//other)*other)
    def __eq__(self,other):
        return (self.real==other.real) and (self.imag==other.imag)
    def norm(self):
        return (self*self.conj()).real
    def withoutunit(self):
        while self.real<0 or self.imag<0:
           self.real,self.imag=self.imag,-self.real

def gcdGaussian(a,b):#implements the euclidean algorithm for computing gcd over ZZ[i]
    while not b == GaussianInteger(0,0):
        b.withoutunit()#this is IMPORTANT!
        a,b = b,a%b
    return a

def pollardGaussian(N,B=8,m=0):#implements pollards p-1 algorithm for ZZ[i]
    if not m:
        m = lcm(B)
    for i in range(10):
        a = GaussianInteger(randint(0,100),randint(0,100)) #here we take a to be a random gaussian integer with with real and imag parts instead of setting a=2 and adding each time
        am_1 = modexp(a,m,N) - GaussianInteger(1,0)
        factor = gcdGaussian(am_1,N)
        if 1 < factor.norm() < N.norm(): #comparing norms
            return factor,N//factor
    return -1

def pollardGaussian2(N,B=8,m=0):#implements pollards p-1 algorithm for ZZ[i] using a different method
    if not m:
        m = lcm(B)
    normN = N.norm() #use the norm of our gaussian integer 
    try:
        f,g = pollard(normN,m=m)
    except:
        return -1
    factor = gcdGaussian(N,GaussianInteger(f,0))
    return factor,N//factor

def lenstraGaussian(N,B=8,m=0):#implements pollards p-1 algorithm for ZZ[i] using a different method
    if not m:
        m = lcm(B)
    normN = N.norm() #use the norm of our gaussian integer 
    facts = lenstra(normN,m=m)
    if facts==-1:
        return -1
    f=facts[0]
    factor = gcdGaussian(N,GaussianInteger(f,0))
    return factor,N//factor

def NvBpollardGaussian(maxB=20):#plots the minimum B needed for various odd values of N
    m=[1]
    for b in range(1,maxB):
        m.append(lcm(b))#precompute all the lcms!
    N = list()
    B = list()
    numOfFails=0#we want to count num of fails
    for i in range (10000):
        n = GaussianInteger(randint(0,10000),randint(0,10000))
        while n==GaussianInteger(0,0):
            n = GaussianInteger(randint(0,10000),randint(0,10000))
        p = n.norm()
        N.append(p)
        b = 1
        while b<maxB:
            if pollardGaussian(n,m=m[b]) == -1:
                b += 1
            else:
                B.append(b)
                break
        if b==maxB: #sends a fail to -1
            B.append(-10)#to make it obvious it which don't work
            numOfFails+=1
    plt.scatter(N,B,s=0.1)
    plt.xlabel('N to be factorised')
    plt.ylabel('smallest B to factorise N')
    plt.show()
    return numOfFails
 
def NvBpollardGaussian2(maxB=20):#plots the minimum B needed for various odd values of N
    m=[1]
    for b in range(1,maxB):
        m.append(lcm(b))#precompute all the lcms!
    N = list()
    B = list()
    numOfFails=0#we want to count num of fails
    for i in range (10000):
        n = GaussianInteger(randint(0,10000),randint(0,10000))
        while n==GaussianInteger(0,0):
            n = GaussianInteger(randint(0,10000),randint(0,10000))
        p = n.norm()
        N.append(p)
        b = 1
        while b<maxB:
            if pollardGaussian2(n,m=m[b]) == -1:
                b += 1
            else:
                B.append(b)
                break
        if b==maxB: #sends a fail to -1
            B.append(-10)#to make it obvious it which don't work
            numOfFails+=1
    plt.scatter(N,B,s=0.1)
    plt.xlabel('N to be factorised')
    plt.ylabel('smallest B to factorise N')
    plt.show()
    return numOfFails

def NvBlenstraGaussian(maxB=20):#plots the minimum B needed for various odd values of N
    m=[1]
    for b in range(1,maxB):
        m.append(lcm(b))#precompute all the lcms!
    N = list()
    B = list()
    numOfFails=0#we want to count num of fails
    for i in range (100):
        n = GaussianInteger(randint(0,10000),randint(0,10000))
        while n==GaussianInteger(0,0):
            n = GaussianInteger(randint(0,10000),randint(0,10000))
        p = n.norm()
        N.append(p)
        b = 1
        while b<maxB:
            if lenstraGaussian(n,m=m[b]) == -1:
                b += 1
            else:
                B.append(b)
                break
        if b==maxB: #sends a fail to -1
            B.append(-10)#to make it obvious it which don't work
            numOfFails+=1
    plt.scatter(N,B,s=0.1)
    plt.xlabel('N to be factorised')
    plt.ylabel('smallest B to factorise N')
    plt.show()
    return numOfFails


####################################################################################################
#factorising ZZ[root(-2)] using two methods

class ZsqrtM2: #creating a class of ZZ[root(-2)]
    def __init__(self,integer,root=0): #initialise an element
        self.integer=integer
        self.root=root
    def __repr__(self): # how to represent a gaussian integer
        if self.root >=0:
            return str(self.integer) +"+" + str(self.root)+ "sqrt(-2)"
        else: 
            return str(self.integer)  + str(self.root)+ "sqrt(-2)"
    def __add__(self,other): # defining addition
        return ZsqrtM2(self.integer+other.integer,self.root+other.root)
    def __sub__(self,other): #defining subtraction
        return ZsqrtM2(self.integer-other.integer,self.root-other.root)
    
    def __mul__(self,other): #defining multiplication
        return ZsqrtM2(self.integer*other.integer-2*self.root*other.root, self.integer*other.root+self.root*other.integer)
   
    def conj(self):
        return ZsqrtM2(self.integer, -self.root)
    def __floordiv__(self,other): # defining floor division so we can take mods, we dont need truediv
        denom = (other.conj() * other).integer
        numer = other.conj() * self
        return ZsqrtM2(numer.integer//denom,numer.root//denom)   
    
    def __mod__(self,other) : #defining mod := the remainder after floor division
        return self-((self//other)*other)
    def __eq__(self,other):
        return (self.integer==other.integer) and (self.root==other.root)
    def norm(self):
        return (self*self.conj()).integer
    
def gcdZsqrtM2(a,b):#implements the euclidean algorithm for computing gcd over ZZ[i]
    while not b == ZsqrtM2(0,0): #sometimes this goes on forever... need to investigate further
        a,b = b,a%b
    return a

def pollardZsqrtM2(N,B=8,m=0):#implements pollards p-1 algorithm for ZZ[i]
    if not m:
        m = lcm(B)
    for i in range(10):
        a = ZsqrtM2(randint(0,100),randint(0,100)) #here we take a to be a random gaussian integer with with real and imag parts instead of setting a=2 and adding each time
        am_1 = modexp(a,m,N) - ZsqrtM2(1,0)
        factor = gcdZsqrtM2(am_1,N)
        if 1 < factor.norm() < N.norm(): #comparing norms
            return factor,N//factor
    return -1    

def pollardZsqrtM2v2(N,B=8,m=0):#implements pollards p-1 algorithm for ZZ[i] using a different method
    normN = N.norm() #use the norm of our gaussian integer 
    f,g = pollard(normN)[:2] #takes the first 2 outputs of pollards on the norm of N
    factor = gcdZsqrtM2(N,ZsqrtM2(f,0))
    return factor,N//factor

#######################################################################################
# Lets try ZZ[sqrt(-5)]

class ZsqrtM5: #creating a class of ZZ[root(-5)]
    def __init__(self,integer,root=0): #initialise an element
        self.integer=integer
        self.root=root
    def __repr__(self): # how to represent a gaussian integer
        if self.root >=0:
            return str(self.integer) +"+" + str(self.root)+ "sqrt(-5)"
        else: 
            return str(self.integer)  + str(self.root)+ "sqrt(-5)"
    def __add__(self,other): # defining addition
        return ZsqrtM5(self.integer+other.integer,self.root+other.root)
    def __sub__(self,other): #defining subtraction
        return ZsqrtM5(self.integer-other.integer,self.root-other.root)
    
    def __mul__(self,other): #defining multiplication
        return ZsqrtM5(self.integer*other.integer-5*self.root*other.root, self.integer*other.root+self.root*other.integer)
   
    def conj(self):
        return ZsqrtM5(self.integer, -self.root)
    def __floordiv__(self,other): # defining floor division so we can take mods, we dont need truediv
        denom = (other.conj() * other).integer
        numer = other.conj() * self
        return ZsqrtM5(numer.integer//denom,numer.root//denom)   
    
    def __mod__(self,other) : #defining mod := the remainder after floor division
        return self-((self//other)*other)
    def __eq__(self,other):
        return (self.integer==other.integer) and (self.root==other.root)
    def norm(self):
        return (self*self.conj()).integer
    
def gcdZsqrtM5(a,b):#We cannot do euclidean algorithm over a non UFD such as ZZ[sqrt(-5)]
    while not b == ZsqrtM5(0,0): #This bit goes on forever!
        a,b = b,a%b
    return a

def pollardZsqrtM5(N,B=8,m=0):#Tries pollards p-1 algorithm for ZZ[sqrt(-5)]
    if not m:
        m = lcm(B)
    for i in range(10):
        a = ZsqrtM5(randint(0,100),randint(0,100)) #here we take a to be a random number with with real and imag parts instead of setting a=2 and adding each time
        am_1 = modexp(a,m,N) - ZsqrtM2(1,0)
        factor = gcdZsqrtM5(am_1,N) #if we can find a different way to take a common factor, then this will work!
        if 1 < factor.norm() < N.norm(): #comparing norms
            return factor,N//factor
    return -1    

def pollardZsqrtM5v2(N,B=8,m=0):#tries pollards p-1 algorithm for ZZ[sqrt(-5)] using a different method
    normN = N.norm() #use the norm of our gaussian integer 
    f,g = pollard(normN)[:2] #takes the first 2 outputs of pollards on the norm of N
    factor = gcdZsqrtM5(N,ZsqrtM5(f,0))
    return factor,N//factor

#######################################################################################
# Lets try ZZ[sqrt(d)]

class Zsqrtd: #creating a class for the ring of integers for Q(sqrt(d))
    def __init__(self,integer,root=0,d=-1): #initialise an element
        self.integer=integer
        self.root=root #if d is 1 mod 4 then this is (1+sqrt(d))/2
        #if d not squarefree raise an error
        for f in range(2,int(abs(d)**0.5)+1):
            if d%f**2==0:
                raise ValueError("d must be squarefree")
        self.d=d
    def __repr__(self,d=-1): # how to represent a number in Q(sqrt(d))
        if self.root >=0:
            if d % 4 != 1:
                return str(self.integer) +"+" + str(self.root)+ "sqrt("+ str(self.d) +")"
            else:
                return str(self.integer) + "+" + str(self.root)+ "(1+sqrt("+ str(self.d) +"))/2"
        else: 
            if d % 4 != 1:
                return str(self.integer)  + str(self.root)+ "sqrt("+ str(self.d) + ")"
            else:
                return str(self.integer)  + str(self.root)+ "(1+sqrt("+ str(self.d) +"))/2"
        
    def __add__(self,other,d=-1): # defining addition
        assert self.d==other.d #gives error if d's arent the same 
        return Zsqrtd(self.integer+other.integer,self.root+other.root,self.d)
    def __sub__(self,other,d=-1): #defining subtraction
        assert self.d==other.d
        return Zsqrtd(self.integer-other.integer,self.root-other.root,self.d)
    
    def __mul__(self,other,d=-1): #defining multiplication
        assert self.d==other.d
        if d % 4 != 1:
            return Zsqrtd(self.integer*other.integer+self.d*self.root*other.root, self.integer*other.root+self.root*other.integer,self.d)
        return Zsqrtd(self.integer*other.integer+self.root*other.root*(self.d-1)//4,self.root*other.integer+other.root*self.integer+self.root*other.root,self.d)
   
    def conj(self,d=-1):
        if d % 4 != 1:
            return Zsqrtd(self.integer, -self.root,self.d)
        return Zsqrtd(self.integer+self.root, -self.root,self.d)
    def __floordiv__(self,other): # defining floor division so we can take mods, we dont need truediv
        assert self.d==other.d
        denom = (other.conj() * other).integer
        numer = other.conj() * self
        return Zsqrtd(numer.integer//denom,numer.root//denom,self.d)
    
    def __mod__(self,other,d=-1) : #defining mod := the remainder after floor division
        assert self.d==other.d
        return self-((self//other)*other)
    def __eq__(self,other,d=-1):
        assert self.d==other.d
        return (self.integer==other.integer) and (self.root==other.root)
    def norm(self,d=-1):
        return (self*self.conj()).integer
    
def gcdZsqrtd(a,b):#implements the euclidean algorithm for computing gcd over ZZ[sqrt(d)]
    #if QuadraticField(a.d,'aaaaa').class_number()!=1:
    #    raise ValueError("Euclidean algorithm doesn't work in this ring")
    while not b == Zsqrtd(0,0,a.d): #sometimes this goes on forever... need to investigate further
        a,b = b,a%b
    return a

def pollardZsqrtd(N,B=8,m=0):#implements pollards p-1 algorithm for ZZ[sqrt(d)]
    if not m:
        m = lcm(B)
    for i in range(10):
        a = Zsqrtd(randint(0,100),randint(0,100),N.d) #here we take a to be a random number with with real and imag parts instead of setting a=2 and adding each time
        am_1 = modexp(a,m,N) - Zsqrtd(1,0,N.d)
        factor = gcdZsqrtd(am_1,N)
        if 1 < factor.norm() < N.norm(): #comparing norms
            return factor,N//factor
    return -1    

def pollardZsqrtd2(N,B=8,m=0):#implements pollards p-1 algorithm for ZZ[sqrt(d)] using a different method
    normN = N.norm() #use the norm of our gaussian integer 
    f,g = pollard(normN,B,m)[:2] #takes the first 2 outputs of pollards on the norm of N
    factor = gcdZsqrtd(N,Zsqrtd(f,0))
    return factor,N//factor
